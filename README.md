                              
Jenkins Pipeline for Java based application using Maven, Docker, Argo CD and Kubernetes
â€¢	Every code push auto-triggers the entire pipeline.

<img width="940" height="329" alt="image" src="https://github.com/user-attachments/assets/d29ccdf0-6d3b-4b0a-beed-5774c9541d47" />

 
Project Overview
This setup implements a fully automated GitOps-style CI/CD pipeline with:
â€¢	GitHub â†’ Source code & Webhook trigger
â€¢	Jenkins CI â†’ Builds Java app, creates Docker image, updates manifest
â€¢	DockerHub â†’ Stores versioned container images
â€¢	Kubernetes Cluster (K8s) â†’ Runs the application
â€¢	ArgoCD â†’ Automatically syncs Kubernetes manifests and deploys new versions

Architecture / Flow
1.	Developer updates code in GitHub
2.	GitHub sends a webhook â†’ Jenkins job auto-triggers
3.	Jenkins:
o	Pulls latest code
o	Builds Spring Boot JAR using Maven
o	Builds Docker image
o	Pushes image to DockerHub
o	Updates Kubernetes deployment manifest with new image tag
o	Applies updated manifest to Kubernetes
o	Triggers ArgoCD Sync
4.	ArgoCD detects changes and updates the application in the cluster
5.	Kubernetes runs the new version automatically
Tools and technologies used
Tools             purpose

Spring Boot	      Backend application
GitHub	          Version control + Webhook
Jenkins	          CI automation
Docker	          Containerization
DockerHub       	Image registry
Kubernetes        Application hosting
ArgoCD	          GitOps continuous deployment
Maven	            Java build tool

Project structure:

myspringapp/
â”œâ”€ k8/                                                                          # Kubernetes manifests
â”‚  â”œâ”€ deployment.yaml                                             # Deployment configuration for Spring Boot app
â”‚  â””â”€ service.yaml                                                       # Service (NodePort/ClusterIP) for app exposure
â”œâ”€ src/
â”‚  â””â”€ main/
â”‚     â”œâ”€ java/com/example/myspringapp/
â”‚     â”‚  â”œâ”€ MySpringAppApplication.java                   # Main Spring Boot application 
â”‚     â”‚  â””â”€ HelloController.java                                     # REST endpoint controller
â”‚     â””â”€ resources/
â”‚        â””â”€ application.properties                                   # Application configuration/server port 9090
â”œâ”€ target/                                                                       # Compiled JAR generated by Maven
â”œâ”€ Dockerfile                                                                 # Docker image build instructions 
â”œâ”€ jenkinsfile                                                    # Full CI/CD pipeline (Git ,Jenkins,Docker,K8s ,ArgoCD)
â”œâ”€ argocd-svc-nodeport.yaml                                     # ArgoCD NodePort service exposure
â”œâ”€ pom.xml                                                                    # Maven config
â””â”€ README.md

----------------------step1: Testing application on localmachine------------------------------------------------------
Pre-requisits: launch ec2 instance and install java and maven on it

 <img width="940" height="529" alt="image" src="https://github.com/user-attachments/assets/fba61227-e2d8-4c50-bdf9-3eee3a678a0c" />

Login from terminal and access EC2 instance
sudo apt update
sudo apt install -y openjdk-17-jdk maven
java -version   # openjdk version "17.0.16" 2025-07-15
mvn -version  # Apache Maven 3.8.7
1.Build the project
mvn clean package    
â€¢	if build is success target/folder created and inside target--> spring_demo-1.0.0.jar created
 <img width="940" height="504" alt="image" src="https://github.com/user-attachments/assets/6d33abb9-24d2-4f51-9086-ea418e91b1d1" />

2.run jar file
java -jar target/spring_demo-1.0.0.jar  
â€¢	copy the public IP and open browser and run http://<publicIP>:9090/
â€¢	make custom TCP 9090 port in inbound rules of AWS EC2 instance is enabled
<img width="835" height="238" alt="image" src="https://github.com/user-attachments/assets/29f4db03-125b-46d7-a055-707231708772" />

3.Push your code to your Github repository
4.install Jenkins on ec2 and trigger pipleline from SCM
â€¢	add webhook in git and enable trigger in your job

http://13.203.196.249:8080/github-webhook/

<img width="940" height="529" alt="image" src="https://github.com/user-attachments/assets/8d7a09f8-1372-4ab4-bc58-2d93d4311165" />

6.install and configure docker,k3s and argocd on ec2 instance

7.add docker and argcd username and password in Jenkins credentials and update same id in jenkinsfile and build the pipeline
 <img width="940" height="529" alt="image" src="https://github.com/user-attachments/assets/323c585d-1fc6-4221-bdaf-abafd916f1dc" />

8.observe the pod creation and deployment.yaml update automatically in git and cli
<img width="940" height="529" alt="image" src="https://github.com/user-attachments/assets/45995552-7250-4227-aa1c-51f96e180704" />

9.docker image created and same has been updated in docker hub and deployment.yaml file
<img width="940" height="328" alt="image" src="https://github.com/user-attachments/assets/702e9844-adb5-4413-994a-361e4d80d749" />

10.Argocd application is running and in sync
 <img width="940" height="529" alt="image" src="https://github.com/user-attachments/assets/07117f98-8bce-4470-92db-dacd7cbfab36" />

11.make some changes in java file and commit in git,jenkin jobs gets auto-triggered by jenkins webhook and all above steps has been implemented without human intervention 
 <img width="940" height="504" alt="image" src="https://github.com/user-attachments/assets/f86a6af4-f601-4e3f-8fab-7ac0d610ef77" />
 <img width="940" height="504" alt="image" src="https://github.com/user-attachments/assets/2b525ae7-61b3-49d9-af52-b9e5ab687199" />

12.modification we made is tracked successfully in Argocd
<img width="940" height="529" alt="image" src="https://github.com/user-attachments/assets/8572f2bc-7fcb-4292-b2db-a834ad0b0371" />
<img width="940" height="529" alt="image" src="https://github.com/user-attachments/assets/f19aaeb1-66b8-472f-9032-f92ac6a64f19" />

 
ðŸš€ End Result
â€¢	One commit â†’ triggers entire CI/CD
â€¢	Docker image gets built & pushed
â€¢	Kubernetes pod auto-rolls out a new version
â€¢	ArgoCD dashboard shows Synced / Healthy
â€¢	Zero manual steps needed







 


     

  
 

 



      
 
 
